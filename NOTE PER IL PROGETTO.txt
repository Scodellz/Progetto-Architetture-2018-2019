

 Questa descrizione ad alto livello si focalizza nel presentare le strutture fondamentali utilizzate dal Cifratore.
 Il programma è stato sviluppato in modo da rispettare il principio di modulatirà.
 Il codice è stato impostato in modo tale da essere più "facilmente" mantenibile, grazie anche alla suddivisione 
 delle funzionalità in piccole procedure.


  CIFRATORE:
  bufferReader : .space[1500]
  bufferkey :    .space[4]
  chiave.txt
  messaggio.txt
  messaggioCifrato.txt
  messaggioDecifrato.txt

  open(messaggio.txt chiave.txt)
  read(messaggio.txt bufferReader chiave.txt bufferKey):
  cifratura(bufferReader bufferkey):
  print(bufferReader messaggioCifrato.txt)
  decifratura(bufferReader bufferkey):
  print(bufferReader messaggioDecifrato.txt)

 Il Cifratore avrà inizialmente il compito di inizializzare la tabella dei salti dedicata agli Algoritmi di Cifratura, 
 successivamente dovrà leggere i file di testo (contenenti la chiave di cifratura e messaggio da cifrare)
 e di caricarli negli appositi buffer.
 Nella fase di Decifratura leggerà il file da decifrare e lo caricherà in bufferReader. La chiave, la letta al passo 
 precedente, sarà letta in senso inverso grazie ad un flag di controllo.
 Alla fine di ogni fase il Cifratore ha il compito di scrivere nei file di uscita, chiamando le procedure apposite.


CIFRATURA E DECIFRATURA:
Cosi come è stato impostato il codice, le responsabilita delle procedure sono state ridotte al minino, infatti 
Visto gli algoritmi ABC hanno degli stati a comune sia durante la Cifratura che durante la Decifratura, il loro settaggio
è stato rachiuso in una procedura che aggiornerà i registri interesati.
La fase di cifratura ha la responsabilita di caricare l'indirizzo della chiave, essendo la prima fase in esecuzione 
Entrambi chimano, la procedura CORE() che eseguira l'efettiva operazione di cifratura o decifratura.


  CIFRATURA      		DECIFRATURA

  setStatusABC()                setStatusABC()
  core()                        core()




CORE:
Core è la procedura generica alla base del funzionamento dell'intero Cifratore, viene infatti utilizzata sia in fase di cifratura che in fase di decifratura.
Core ha l'unica responsabilita di chiamare gli algoritmi, il solo comportamento è stato determinato precedentemente, attraverso la chiamata a setStatusABC()

il suo comportamento è determinato da una "variabile" di stato definita in $s7, settata ad 0 quando siamo in fase di cifratura e viene settata ad 1 quando siamo in fase di decifratura.
 
Core carica gli indirizzi di bufferReader e statusABC al suo interno, eseguirà un controllo per capire da che punto iniziare a leggere la chiave, se ci troviamo in fase di Cifratura leggera la chiave da sinistra verso destra, se ci troviamo in nella fase di decifratura leggera la chiave in senso inverso.
Core leggerà il buffer dedicato alle chiavi e per ogni simbolo trovato all'interno chiamerà il suo algoritmo associato. Per evitare la scrittura di una serie di beq a cascata è stato adoperata una JAT-table dedicata agli algoritmi di cifratura : algorithmJAT().
Essendo le chiavi rappresentate in forma decimale in un intervallo tra 65 e 69, Core riesci a distinguire i vari algoritmi attraverso l'operazione 
di sottrazione, vengono quindi usati i risultati che vanno da 0 a 4 , che moltiplicati con gli opportuni indici permettono di Saltare alla posizione giusta nella tabella dedicata agli algoritmi.

Per motivi di chiarezza il calcolo e il salto al algoritmo corrente è stato demandato ad una procedura dedicata, che al suo ritorno aggiorna "l'indice"
delle chiavi e riprende la lettura della chiave successiva. la lettura delle chiavi finiesce solo quando viene trovato lo zero,
che indica fine stringa.

L'array di riferimento per entrambe le operazioni è sempre bufferReader. All'inizio del programma contiene il messaggio originario,
mentre durante lo svolgimento dei vari algoritmi di cifratura conterrà le cifrature parziali ottenute dalle chiamate dei vari 
algoritmi e alla fine conterrà il messaggio finale da scrivere nel file di output.

Scelte implementative:
Nel codice è stato riscontratta la necessita di introdurre in punti ben precisi un procedura dedicata alla pulizia di tutti i buffer .space che vengono utilizzati. Perche in certe situazioni, in presenza di messaggio molto brevi, vengo stampati caratteri rimasti nel corso delle cifrature
precedenti





